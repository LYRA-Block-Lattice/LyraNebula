@inherits Fluxor.Blazor.Web.Components.FluxorComponent
@page "/webwallet"
@page "/webwallet/swap/{swap?}"

@using Nebula.Store.WebWalletUseCase
@using Nebula.Data
@using Microsoft.Extensions.Configuration
@using Blazored.LocalStorage
@using Microsoft.Extensions.Logging
@using Microsoft.Extensions.Options
@inject IConfiguration Configuration
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject SampleAPI SampleAPI
@inject Blazored.LocalStorage.ILocalStorageService localStore
@inject ILogger<WebWallet> logger
@inject IOptionsMonitor<SwapOptions> swapOptions
@inject ILyraAPI lyraClient
@using Nebula.Components;

<h1>Web Wallet for @LyraGlobal.PRODUCTNAME</h1>
<hr />
@if (walletState.Value.IsLoading)
{
<div class="spinner"></div>
}

@if(!string.IsNullOrEmpty(walletState.Value.error))
{
<p>
    <Alert Type="@AlertType.Error"
           Message="Wallet Operation Error"
           Description="@walletState.Value.error"
           ShowIcon="true" Closable OnClose="ClearError"/>
</p>
}

@if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Main)
{
<div>
    <span>
        <button class="btn btn-primary" @onclick="Send">
            Send
        </button>
        <button class="btn btn-primary" @onclick="Refresh">
            Receive
        </button>
        <button class="btn btn-primary" @onclick="Staking">
            Staking
        </button>

@*        <button class="btn btn-primary" @onclick="SwapToken">
            Token Swap
        </button>*@
        <button class="btn btn-primary" @onclick="StartDex">
            DEX
        </button>
        @*    <button class="btn btn-primary" @onclick="SwapTLYR">
                TLYR Gateway
            </button>*@

                &nbsp;
        <button class="btn btn-primary" @onclick="Transactions">
            Transactions
        </button>

        <button class="btn btn-primary" @onclick="Settings">
            Settings
        </button>
        &nbsp;
        <button class="btn btn-primary" @onclick="CloseWallet">
            Close
        </button>
    </span>
    &nbsp;&nbsp;&nbsp;
    @if (Configuration["network"] != "mainnet" && walletState.Value.wallet.BaseBalance == 0m && walletState.Value.freeTokenTimes < 3 && !walletState.Value.freeTokenSent)
        {
    <span>
        <button style="float: right;" class="btn btn-extra" @onclick="FreeToken">
            Get Free Token
        </button>
    </span>
        }
</div>
<hr />
    <div>
        <Space>
            @foreach (var kvp in walletState.Value.wallet.GetLatestBlock().Balances)
            {
                <SpaceItem>
                    <Card Title="@kvp.Key" Style="width:300px;">
                        <Extra>
                            <Button Type="@ButtonType.Text" OnClick="@(async ()=>{ await SendX(kvp.Key); })">
                                Send
                            </Button>
                        </Extra>
                        <Body>
                            <p style="font-size: xx-large;"><b>@($"{kvp.Value.ToBalanceDecimal():N2}")</b></p>
                        </Body>
                    </Card>
                </SpaceItem>
            }

        </Space>


    </div>

}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.DEX)
{
<div>
    <button class="btn btn-primary" @onclick="CancelSave">Return</button>
</div>
<hr />
<h3>Lyra DEX</h3>
<hr />
<div>
    @*  
        list supported blockchain
        on

    *@
    <DexWallets></DexWallets>
</div>
<hr />
<div>
    <button class="btn btn-primary" @onclick="CancelSave">Return</button>
</div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Staking)
{
<div>
    <button class="btn btn-primary" @onclick="CancelSave">Return</button>
</div>
<hr />
<h3>Staking</h3>
<hr />
<p>
    <div><h4>All Stakings</h4></div>
    <div>
        <table class="table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Staking Amount</th>
                    <th>Compound Mode</th>
                    <th>Total Reward</th>
                    <th>Start Time</th>
                    <th>Staking Days</th>
                    <th>Staking to Account</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var stk in walletState.Value.brokerAccounts.Where(a => a is StakingGenesis)
                     .Cast<StakingGenesis>())
                    {
                <tr>
                    <td>@stk.Name</td>
                    @if (walletState.Value.stkBalances != null)
                            {
                    <td>@walletState.Value.stkBalances[stk.AccountID]</td>
                            }
                            else
                            {
                    <td>0</td>
                            }
                    <td>@stk.CompoundMode</td>
                    <td>@walletState.Value.stkRewards[stk.AccountID]</td>
                    <td>@stk.TimeStamp</td>
                    <td>@stk.Days</td>
                    <td>@stk.Voting</td>
                    <td>
                        <a href="" @onclick="@(e => AddStkAsync(e, stk.AccountID))" @onclick:preventDefault><u>Add Staking</u></a>
                        &nbsp;
                                <Popconfirm Title="Unstaking within the promised staking period will pay 0.8% panalise fee. "
                                    OnConfirm="@(e => RmStk(e, stk.AccountID))"
                                    OkText="Yes, I know."
                                    CancelText="No, cancel unstaking">
                                    <a style="color:blue"><u>Unstaking</u></a>
                                </Popconfirm>
                    </td>
                </tr>
                    }
            </tbody>
        </table>
    </div>
</p>
<p>
    <div><h4>All Profiting</h4></div>
    <div>
        <table class="table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Share Ratio</th>
                    <th>Seats</th>
                    <th>Profiting Account ID</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var pft in walletState.Value.brokerAccounts.Where(a => a is ProfitingGenesis)
                    .Cast<ProfitingGenesis>())
                    {
                <tr>
                    <td>@pft.Name</td>
                    <td>@pft.PType</td>
                    <td>@pft.ShareRito</td>
                    <td>@pft.Seats</td>
                    <td>
                        @pft.AccountID
                    </td>
                </tr>
                    }
            </tbody>
        </table>
    </div>
</p>

<div>
    <h3>Create new staking account</h3>
    <p>
        Name:
        <input size="60" type="text" @bind="@stkName" />
    </p>
    <p>
        Staking For Address:
        <input size="100" type="text" @bind="@stkVoting" />
    </p>
    <p>
        Days of staking:
        <input size="10" type="text" @bind="@stkDays" />
    </p>
    <p>
        Compound staking mode:
        <input size="10" type="checkbox" @bind="@stkCompound" />
    </p>
    <div>
        <button class="btn btn-primary" @onclick="StakingCreate">Create Staking</button>
    </div>
</div>
<hr />
<div>
    <h3>Create new profiting account</h3>
    <p>
        Name:
        <input size="60" type="text" @bind="@pftName" />
    </p>
    <p>
        Type:
        <select style="height: 40px; width: 380px" @bind="@pftType">
            <option value="Node">Node</option>
            <option disabled value="Oracle">Oracle</option>
            <option disabled value="Merchant">Merchant</option>
            <option value="Yield">Yield</option>
        </select>
    </p>
    <p>
        Ratio to share to staking (0% - 100%):
        <input size="10" type="text" @bind="@pftShare" />
    </p>
    <p>
        Number of staking (0 - 100):
        <input size="10" type="text" @bind="@pftSeats" />
    </p>
    <div>
        <button class="btn btn-primary" @onclick="ProfitingCreate">Create Profiting Account</button>
    </div>
</div>
<hr />
<div>
    <button class="btn btn-primary" @onclick="CancelSave">Return</button>
</div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Settings)
{
<h3>Settings</h3>
<hr />
<div>
    <p><span title="Click to toggle to display" @onclick="ToggleKey">Your wallet's private key is (click to unhide/hide): </span><span>@altDisplay</span></p>
    <p>Your wallet's address is: <a href="/showblock/@walletState.Value.wallet.AccountId">@walletState.Value.wallet.AccountId</a></p>
    <p>Your wallet's balance is: @walletState.Value.balanceString</p>
    <p>Your are now voting for: @walletState.Value.wallet.VoteFor</p>

    <p>
        Vote For Address:
        <input size="100" type="text" @bind="@voteAddr" />
    </p>
    <div>
    <p style="color: red">Please save private key properly if you want to open this wallet again.</p>
    </div>
    <hr />

    <button class="btn btn-primary" @onclick="SaveSettings">Save</button>
    <button class="btn btn-primary" @onclick="CancelSave">Cancel</button>
</div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Send)
{
<h3>Sending token</h3>
<hr />
<div>
    <p>
        Destination Wallet Address:<br />
        <input size="120" type="text" @bind="@dstAddr" />
    </p>
    <p>
        Token Name:<br />
        <input size="20" type="text" @bind="@tokenName" />
    </p>
    <p>
        Amount:<br />
        <input size="20" type="text" @bind="@amount" />
    </p>
    <hr />
    <button class="btn btn-primary" @onclick="SendToken">Send Token</button>
    <button class="btn btn-primary" @onclick="CancelSend">Cancel</button>
</div>

}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Transactions)
{
<h3>Transactions</h3>
<hr />
<div>
    <button class="btn btn-primary" @onclick="Return">Return</button>
</div>
@if (walletState.Value.txs != null)
    {
<pre>
        @foreach(var tx in walletState.Value.txs)
        {
            @tx <br />

        }
        </pre>
<div>
    <button class="btn btn-primary" @onclick="Return">Return</button>
</div>
    }
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.SwapToken)
{
<h3>Lyra Swap</h3>
<hr />

<h5>Swap from:</h5>
<div>
    <span>
        <select style="height: 40px; width: 380px" @bind="swapFromToken">
            @foreach (var tkn in LyraAsserts)
                {
            <option value="@tkn.Name">@tkn.Name</option>
                }
        </select>
    </span>
    <span>
        <input style="height: 40px; " size="20" placeholder="Count" type="text" @bind="@swapFromCount" />
    </span>
</div>
<p>@fromTokenBalance @swapFromToken available to swap</p>
<h5>Swap to:</h5>
<div>
    <span>
        <select style="height: 40px; width: 380px" @bind="swapToToken">
            @foreach (var tkn in LyraAsserts)
                {
            <option value="@tkn.Name">@tkn.Name</option>
                }
        </select>
    </span>
</div>
<br />
<div>
    Slippage: <input size="5" type="text" @bind="@slippage" /> %
</div>
<hr />
<p>
    <div>Minimum Received: @swapToCount @swapToToken.</div>
    @if (swapCalculator != null)
        {
    <div>Price: @(swapCalculator.Price) @swapFromToken per @swapToToken</div>
    <div>Price Impact: @(Math.Round(swapCalculator.PriceImpact * 100, 4))%</div>
    <div>Liquidate pool provider fee: @swapCalculator.PayToProvider @swapFromToken</div>
    <div>Lyra protocol fee: @swapCalculator.PayToAuthorizer LYR</div>
        }
</p>
<p><pre>@PoolInfo</pre></p>
<hr style="color: white" />
<div>
    <button disabled="@IsDisabled" class="btn btn-primary" @onclick="DoSwapLyraToken">Swap</button>
</div>
<p>@swapResultMessage</p>
<hr style="color: white" />
<p>@walletState.Value.Message</p>
<div>
    <button class="btn btn-primary" @onclick="Return">Return</button>
</div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.SwapTLYR)
{
<h3>Swap tokens between LYR and TLYR (ERC20 Tether of LYR)</h3>
@if (Configuration["network"] == "testnet")
    {
<p>Current supported Ethereum network: Rinkeby Test Network.</p>
    }
@if (Configuration["network"] == "mainnet")
    {
<p>Current supported Ethereum network: Ethereum Main Network.</p>
    }
<p>Add TLYR token to MetaMask by Ethereum Contract hash: @swapOptions.CurrentValue.ethContract</p>
<p>Balance of LYR reserve account: <b>@lyrReserveBalance</b></p>
<p>Balance of TLYR reserve account: <b>@tlyrReserveBalance</b></p>
<p style="color:blue"><i>@queryingNotify</i></p>
@if (!MetamaskAvailable)
    {
<p>To use swap, you need to install MetaMask wallet. </p>
<NavLink href="https://metamask.io/download.html">Get MetaMask</NavLink>
    }
    else
    {
<hr />
@if (!EthereumEnabled)
        {
@*<button class="btn btn-primary" @onclick="@EnableEthereumAsync">Connect MetaMask Wallet</button>*@
<hr />
        }
        else
        {
<h3>Swap between LYR and TLYR</h3>
<p>My Lyra Account @walletState.Value.wallet.AccountId on @Configuration["network"]</p>
<p>My Etnereum Account @SelectedAccount on @CurrentChainName</p>

<h5>Swap from:</h5>
<div>
    <span>
        <select style="height: 30px; width: 80px" @bind="swapFromToken">
            <option selected>LYR</option>
            <option>TLYR</option>
        </select>
    </span>
    <span>
        <input size="30" placeholder="Count" type="text" @bind="@swapFromCount" />
    </span>
</div>
<p>@fromTokenBalance @swapFromToken available to swap</p>
<h5>Swap to:</h5>
<div>
    <span>
        <select style="height: 30px; width: 80px" @bind="swapToToken">
            <option>LYR</option>
            <option selected>TLYR</option>
        </select>
    </span>
    <span>
        <input size="130" placeholder="Swap To Address" type="text" @bind="@swapToAddress" />
    </span>
</div>
<p>You will get @swapToCount @swapToToken to address @swapToAddress</p>
<hr style="color: white" />
<p>Service fee: @swapFeeDesc</p>
<hr />
<div>
    <button disabled="@IsDisabled" class="btn btn-primary" @onclick="BeginSwapTLYR">Swap</button>
</div>
<p>@swapResultMessage</p>
<p>@walletState.Value.Message</p>
        }
    }
<div>
    <button class="btn btn-primary" @onclick="Return">Return</button>
</div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.FreeToken)
{
<h3>Verify and get free LYR</h3>
<hr />
<div>
    <p>Current balance of faucet account: <em>@walletState.Value.faucetBalance</em> LYR</p>
</div>

<div class="section">
    <ReCAPTCHA @ref="reCAPTCHAComponent" SiteKey="6Lftd8gZAAAAAK5G9aHUFY7wtV1yocfAf2Vj-EmI" OnSuccess="OnSuccess" OnExpired="OnExpired" />
</div>

<div class="section">
    <button class="btn btn-extra" @onclick="OnClickPost" disabled="@walletState.Value.DisablePostButton">
        Send me Token!
    </button>
    &nbsp;&nbsp;
    <button class="btn btn-primary" @onclick="Return">Return</button>
</div>
}
else
{
<div>
    <button class="btn btn-primary" @onclick="CreateWallet">
        Create New Wallet
    </button>
</div>
<hr />
<div>
    <p>Private Key:</p>
    <p><input size="100" type="text" @bind="prvKey" /></p>
    <p>
        <button class="btn btn-primary" @onclick="RestoreWallet">
            Restore Wallet
        </button>
    </p>
</div>
}

@code {

    private ReCAPTCHA reCAPTCHAComponent;

    private async Task<decimal> GetAmountInput()
    {
        string prompted = await JS.InvokeAsync<string>("prompt", "How many LYR do you want to stake?"); // Prompt
        if (prompted == null)
            return 0;
        return decimal.Parse(prompted);
    }

    private void OnSuccess()
    {
        Dispatcher.Dispatch(new WebWalletReCAPTCHAValidAction { ValidReCAPTCHA = true });
    }

    private void OnExpired()
    {
        Dispatcher.Dispatch(new WebWalletReCAPTCHAValidAction { ValidReCAPTCHA = false });
    }

    private async Task OnClickPost()
    {
        if (walletState.Value.ValidReCAPTCHA)
        {
            var response = await reCAPTCHAComponent.GetResponseAsync();
            try
            {
                Dispatcher.Dispatch(new WebWalletReCAPTCHAServerAction { ServerVerificatiing = true });

                var result = await SampleAPI.Post(response);
                if (result.Success)
                {
                    Dispatcher.Dispatch(new WebWalletSendMeFreeTokenAction
                    {
                        wallet = walletState.Value.wallet,
                        faucetPvk = Configuration["faucetPvk"]
                    });
                    //Navigation.NavigateTo("/valid");
                }
                else
                {
                    await JS.InvokeAsync<object>("alert", string.Join(", ", result.ErrorCodes));

                    Dispatcher.Dispatch(new WebWalletReCAPTCHAServerAction { ServerVerificatiing = false });
                }
            }
            catch (HttpRequestException e)
            {
                await JS.InvokeAsync<object>("alert", e.Message);

                Dispatcher.Dispatch(new WebWalletReCAPTCHAServerAction { ServerVerificatiing = false });
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var key = Configuration["network"] + "freelyr";
        if (walletState.Value.freeTokenTimes.HasValue)
        {
            // if it need save
            var oldValue = await localStore.GetItemAsync<string>(key);
            int oldCount;
            if (oldValue == null || (int.TryParse(oldValue, out oldCount) && oldCount < walletState.Value.freeTokenTimes))
            {
                await localStore.SetItemAsync(key, walletState.Value.freeTokenTimes.ToString());
            }
        }
        else
        {
            var oldValue = await localStore.GetItemAsync<string>(key);
            int oldCount;
            if (oldValue != null && int.TryParse(oldValue, out oldCount))
            {
                walletState.Value.freeTokenTimes = oldCount;
            }
            else
            {
                walletState.Value.freeTokenTimes = 0;
            }
        }

        //MetamaskAvailable = await metamaskService.CheckMetamaskAvailability();
    }

    // swap
    bool MetamaskAvailable { get; set; }
    bool EthereumEnabled { get; set; }
    string CurrentChainName { get; set; }
    string SelectedAccount { get; set; }
    string BlockHash { get; set; }
    string TransactionHash { get; set; }
    string ErrorTransferMessage { get; set; }

    //protected async Task EnableEthereumAsync()
    //{
    //    EthereumEnabled = await metamaskService.EnableEthereumAsync();
    //    if (EthereumEnabled)
    //    {
    //        var dotNetObjRef = DotNetObjectReference.Create(this);
    //        var bOk = await metamaskService.RegisterEventsAsync(dotNetObjRef);

    //        CurrentChainName = await metamaskService.GetChainName();
    //        SelectedAccount = await metamaskService.GetSelectedAccount();
    //    }
    //}

    protected async Task GetBlockHashAsync()
    {
        //var web3 = new Nethereum.Web3.Web3();
        //web3.Client.OverridingRequestInterceptor = metamaskInterceptor;
        //var block = await web3.Eth.Blocks.GetBlockWithTransactionsByNumber.SendRequestAsync(new HexBigInteger(1));
        //BlockHash = block.BlockHash;
    }

    protected async Task TransferEtherAsync()
    {
        //try
        //{
        //    var web3 = new Nethereum.Web3.Web3();
        //    web3.Client.OverridingRequestInterceptor = metamaskInterceptor;

        //    TransactionHash = await web3.Eth.GetEtherTransferService().TransferEtherAsync("0x13f022d72158410433cbd66f5dd8bf6d2d129924", 0.001m);
        //}
        //catch (Exception ex)
        //{
        //    ErrorTransferMessage = ex.Message;
        //}
    }
}
