@namespace UserLibrary.Components

@using Blazorise.Components
@using Fluxor
@using Lyra.Core.API
@using Lyra.Core.Blocks
@using Lyra.Data.API
@using Lyra.Data.Crypto
@using Microsoft.Extensions.Configuration
@using Nebula.Store.WebWalletUseCase
@using UserLibrary.Data
@inject IConfiguration Configuration
@inject ILyraAPI lyraClient
@inject AntDesign.MessageService _message

<div class="swc">

@if (ui == UI.Entry)
{
        <div style="padding: 14px; width: 370px">
            <Button Color="Color.Primary" Block class="rounded-pill"
                Clicked="@(async ()=>{ await OpenAddLiquidityUI(); })">Add Liquidity</Button>
        <p>
            <div>Your Liquidity</div>
        </p>
        <div>(TBA)</div>
        </div>
}

@if (ui == UI.Adding)
{
    <div style="padding: 14px; width: 370px">
        <AntDesign.Button Type="@AntDesign.ButtonType.Primary" Shape="@AntDesign.ButtonShape.Circle"
            Icon="@AntDesign.IconType.Outline.ArrowLeft"
            OnClick="BackEntry" />
        &nbsp;Add Liquidity
    </div>
    <div>
        <table class="swt">
            <tr>
                <td>Input</td>
                <td>Balance: @($"{balance1:N8}")</td>
            </tr>
            <tr>
                <td>
                    <div class="round">
                        <NumericEdit TValue="decimal" Style="width: 100px; background: white; border:none;"  lang="en-us" DecimalsSeparator="."
                            @bind-Value="@amount1" />
                    </div>
                </td>
                <td>
                    <div class="round">
                <SelectList TItem="Ticker"
                    TValue="string"
                    Data="@tickers"
                    TextField="@((item)=>item.Name)"
                    ValueField="@((item)=>item.dbname)"
                    SelectedValue="@selectedValue1"
                    SelectedValueChanged="@OnSelectedItemChangedHandler1"
                    Style="width:200px; background: white; border:none;"
                    DefaultItemText="Choose Token" />
                    </div>
                </td>
            </tr>
            <tr>
                <td><AntDesign.Icon Type="plus-circle" Theme="outline" Style="font-size: x-large;" /></td>
                <td></td>
            </tr>
            <tr>
                <td>Input</td>
                <td>Balance: @($"{balance2:N8}")</td>
            </tr>
            <tr>
                <td>
                    <div class="round">
                        <NumericEdit TValue="decimal" Style="width: 100px; background: white; border:none;" lang="en-us" DecimalsSeparator="."
                            @bind-Value="@amount2" />
                    </div>
                </td>
                <td>
                    <div class="round">
                <SelectList TItem="Ticker"
                    TValue="string"
                    Data="@tickers"
                    TextField="@((item)=>item.Name)"
                    ValueField="@((item)=>item.dbname)"
                    SelectedValue="@selectedValue2"
                    SelectedValueChanged="@OnSelectedItemChangedHandler2"
                    Style="width:200px; background: white; border:none;"
                    DefaultItemText="Choose Token" />
                    </div>
                </td>
            </tr>
            @if(havepool)
            {
@*                <tr>
                    <td>Token Pair</td>
                    <td>@pairinfo</td>
                </tr>*@
                <tr>
                    <td>Pool Liquidate</td>
                    <td>@pairliquid</td>
                </tr>
                <tr>
                    <td>Your Share</td>
                    <td>@pairshare</td>
                </tr>
                <tr>
                    <td colspan="2">
                        <AntDesign.Button Disabled="@(!alenabled)" Block Type="@AntDesign.ButtonType.Primary" 
                        Size="ButtonSize.Large" Shape="@AntDesign.ButtonShape.Round"
                        OnClick="@(async ()=>{ await PoolDeposit(); })">Add Liquidate</AntDesign.Button>
                    </td>
                </tr>
                @if(canremove)
                {
                <tr>
                    <td colspan="2"><AntDesign.Divider>Or</AntDesign.Divider>
                    <AntDesign.Button Disabled="@(!alenabled)" Block Type="@AntDesign.ButtonType.Primary" 
                    Size="ButtonSize.Large" Shape="@AntDesign.ButtonShape.Round"
                    OnClick="@(async ()=>{ await PoolWithdraw(); })">Remove All Your Share</AntDesign.Button>    
                    </td>
                </tr>
                }
            }
            else
            {
                <tr>
                    <td colspan="2">No pool for selected pair.</td>
                </tr>
                <tr>
                <td colspan="2" style="padding: 14px">
                    @if(walletState.Value.wallet == null)
                    {
                        <a href="/webwallet"> <AntDesign.Button Block Type="@AntDesign.ButtonType.Primary"
                        Size="ButtonSize.Large" Shape="@AntDesign.ButtonShape.Round"
                        >Open Wallet to Create a Pool</AntDesign.Button></a>
                    }
                    else
                    {
                        <AntDesign.Button Disabled="@(!clenabled)" Block Type="@AntDesign.ButtonType.Primary" 
                        Size="ButtonSize.Large" Shape="@AntDesign.ButtonShape.Round"
                        OnClick="@(async ()=>{ await CreateLiquidity(); })">Create Liquidity Pool</AntDesign.Button>
                    }
                </td>
            </tr>

            }

        </table>
    </div>

}

</div>

@code {

    [Inject]
    private IState<WebWalletState> walletState { get; set; }

    [Inject]
    private IDispatcher Dispatcher { get; set; }

    enum UI { Entry, Adding }
    UI ui;

    private decimal _amount1;
    public decimal amount1
    {
        get
        {
            return _amount1;
        }
        set
        {
            if(_amount1 != value)
            {
                _amount1 = value;
                updateBtn1(_amount1);
            }
            else
                _amount1 = value;
        }
    }

    private decimal _amount2;
    public decimal amount2
    {
        get
        {
            return _amount2;
        }
        set
        {
            if(_amount2 != value)
            {
                _amount2 = value;
                updateBtn2(_amount2);
            }
            else
                _amount2 = value;
        }
    }
    decimal balance1, balance2;
    List<Ticker> tickers;
    Ticker selectedTicker1;
    Ticker selectedTicker2;
    string selectedValue1;
    string selectedValue2;

    bool havepool;
    bool clenabled;
    bool alenabled;
    bool canremove;

    string apiresult;

    TransactionBlock poolblk;
    RenderFragment pairinfo, pairliquid, pairshare;

    private string GN(string dbname)
    {
        return dbname.Replace("tether/", "$");
    }

    protected override void OnInitialized()
    {
        ui = UI.Entry;
        base.OnInitialized();
    }

    private void BackEntry()
    {
        ui = UI.Entry;
    }

    private async Task PoolWithdraw()
    {
        var result = await walletState.Value.wallet.RemoveLiquidateFromPoolAsync(selectedTicker1.dbname, selectedTicker2.dbname);
        if(result.Successful())
        {
            await _message.Success($"Remove liquidate success.");
            updateBtn1(amount1);

            await walletState.Value.wallet.SyncAsync(null);
            UpdateBalance();
        }
        else
        {                
            _message.Error($"Failed remove liquidate. {result.ResultCode}");
        }
    }

    private async Task PoolDeposit()
    {
        var result = await walletState.Value.wallet.AddLiquidateToPoolAsync(selectedTicker1.dbname, amount1, selectedTicker2.dbname, amount2);
        if(result.Successful())
        {
            await _message.Success($"Add liquidate success.");
            updateBtn1(amount1);

            await walletState.Value.wallet.SyncAsync(null);
            UpdateBalance();
        }
        else
        {                
            _message.Error($"Failed add liquidate. {result.ResultCode}");
        }
    }

    private async Task CreateLiquidity()
    {
        var poolCreateResult = await walletState.Value.wallet.CreateLiquidatePoolAsync(selectedTicker1.dbname, selectedTicker2.dbname);
        if(poolCreateResult.Successful())
        {
            await Task.Delay(5000);
            await _message.Success($"Waiting for pool be created...");
            await Task.Delay(5000);
            await PoolDeposit();
        }
        else
        {
            _message.Error($"Pool created failed. {poolCreateResult.ResultCode}");
        }

    }

    private async Task OpenAddLiquidityUI()
    {
        var lc = LyraRestClient.Create(Configuration["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");

        // for api sign only
        var pk = "n4uh7o2kAerPZQSNBRirzA3pSUBEuEhs6r7oRwpV6Dgbs3FvY";
        var pub = "LBRzScs8NwMcr7U8i9a8sSWETseWf3TLge4CVJy6as24hSB4hwtZ5jKTbHJdoVZBJiNC2LpjN9MQB719Py9YxXo2xpLxnS";

        var lsbret = await lc.GetLastServiceBlockAsync();

        var sign = Signatures.GetSignature(pk, (lsbret.GetBlock() as ServiceBlock).Hash, pub);
        var tokens = await lc.GetTokenNamesAsync(pub, sign, "(null)");

        tickers = tokens.Entities
            .Where(a => !a.StartsWith("unittest/"))
            .Select(a => new Ticker
                {
                    dbname = a,
                    Name = a.Replace("tether/", "$")
            })
            .OrderBy(a => a.Name)
            .ToList();
        tickers.Insert(0, new Ticker{ dbname = "LYR", Name = "LYR" });

        ui = UI.Adding;
    }

    private void updateBtn1(decimal? a)
    {
        amount1 = a ?? 0;
        updateBtn(amount1);
    }

    private void updateBtn2(decimal? a)
    {
        amount2 = a ?? 0;
        updateBtn(amount2);
    }
    private void updateBtn(decimal a)
    {
        if(selectedTicker1 != null && selectedTicker2 != null && selectedTicker1 != selectedTicker2)
        {
            _ = Task.Run(async () =>
            {
                var lc = LyraRestClient.Create(Configuration["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");
                var existspool = await lc.GetPoolAsync(selectedTicker1.dbname, selectedTicker2.dbname);
                if (existspool.PoolAccountId != null)
                {
                    havepool = true;

                    var info = $"{existspool.Token0} vs {existspool.Token1}";
                    pairinfo = 
    @<p>@info</p>
    ;
                    var latestret = await lc.GetLastBlockAsync(existspool.PoolAccountId);
                    if(latestret.Successful())
                    {
                        var latestblk = latestret.GetBlock() as TransactionBlock;
                        poolblk = latestblk;

                        if(latestblk.Balances.ContainsKey(selectedTicker1.dbname) && latestblk.Balances[selectedTicker1.dbname] > 0)
                        {
                            if(a > 0 && a == amount1)
                            {
                                //var swapcal = new SwapCalculator(existspool.Token0, existspool.Token1, poolblk,
                                //    existspool.Token0, amount1, 0);

                                var poolRito = latestblk.Balances[selectedTicker1.dbname].ToBalanceDecimal() / latestblk.Balances[selectedTicker2.dbname].ToBalanceDecimal();
                                amount2 = Math.Round(amount1 / poolRito, 8);
                            }
                            else if(a > 0 && a == amount2)
                            {
                                //var swapcal = new SwapCalculator(existspool.Token0, existspool.Token1, poolblk,
                                //    existspool.Token1, amount2, 0);

                                var poolRito = latestblk.Balances[selectedTicker1.dbname].ToBalanceDecimal() / latestblk.Balances[selectedTicker2.dbname].ToBalanceDecimal();
                                amount1 = Math.Round(amount2 * poolRito, 8);
                            }
                        }


                        var line1 = $"{latestblk.Balances[existspool.Token0].ToBalanceDecimal()} {GN(existspool.Token0)}";
                        var line2 = $"{latestblk.Balances[existspool.Token1].ToBalanceDecimal()} {GN(existspool.Token1)}";
                        pairliquid = 
    @<p>@line1<br />
@line2
    </p>
    ;
                        var pool = latestblk as IPool;
                        if(walletState.Value.wallet != null && pool.Shares.ContainsKey(walletState.Value.wallet.AccountId))
                        {
                            canremove = true;
                            var shareinfo = $"{Math.Round(pool.Shares[walletState.Value.wallet.AccountId].ToRitoDecimal() * 100, 4)} %";
                            pairshare =
    @<p>@shareinfo</p>
    ;
                        }
                        else
                        {
                            canremove = false;
                            pairshare =
    @<p>No Share in Pool</p>
    ;
                        }
                    }
                    else
                    {                        
                        pairliquid =
    @<p>No Liquidate in Pool</p>
    ;
                            pairshare =
    @<p>No Share in Pool</p>
    ;
                    }
                    
                }                    
                else
                {
                    havepool = false;
                    pairinfo = 
    @<p>Pool Not Exists.</p>
    ;
                }

                clenabled = amount1 > 0 && amount2 > 0 && balance1 > 0 && balance2 > 0 && selectedTicker1 != selectedTicker2;
                alenabled = amount1 > 0 && amount2 > 0 && amount1 <= balance1 && amount2 <= balance2;

                await InvokeAsync(() => StateHasChanged());
            });
        }

        clenabled = amount1 > 0 && amount2 > 0 && balance1 > 0 && balance2 > 0 && selectedTicker1 != selectedTicker2;
        alenabled = amount1 > 0 && amount2 > 0 && amount1 <= balance1 && amount2 <= balance2;
    }

    private void OnSelectedItemChangedHandler1(string value)
    {
        selectedValue1 = value;
        selectedTicker1 = tickers.FirstOrDefault(a => a.dbname == value);
        if(walletState.Value.wallet != null)
        {
            var blk = walletState.Value.wallet.GetLatestBlock();
            if (blk != null && blk.Balances.ContainsKey(value))
                balance1 = blk.Balances[value].ToBalanceDecimal();
            else
                balance1 = 0;
        }
        else
            balance1 = 0;

        updateBtn(0);
    }
    private void OnSelectedItemChangedHandler2(string value)
    {
        selectedValue2 = value;
        selectedTicker2 = tickers.FirstOrDefault(a => a.dbname == value);
        if(walletState.Value.wallet != null)
        {
            var blk = walletState.Value.wallet.GetLatestBlock();
            if (blk != null && blk.Balances.ContainsKey(value))
                balance2 = blk.Balances[value].ToBalanceDecimal();
            else
                balance2 = 0;
        }
        else
            balance2 = 0;

        updateBtn(0);
    }

    private void UpdateBalance()
    {
        if(walletState.Value.wallet != null)
        {
            var blk = walletState.Value.wallet.GetLatestBlock();
            if (blk != null && blk.Balances.ContainsKey(selectedTicker1.dbname))
                balance1 = blk.Balances[selectedTicker1.dbname].ToBalanceDecimal();
            else
                balance1 = 0;

            if (blk != null && blk.Balances.ContainsKey(selectedTicker2.dbname))
                balance2 = blk.Balances[selectedTicker2.dbname].ToBalanceDecimal();
            else
                balance2 = 0;

            Dispatcher.Dispatch(new WebWalletRefreshBalanceAction { wallet = walletState.Value.wallet });
        }

        InvokeAsync(() => StateHasChanged());
    }
}
