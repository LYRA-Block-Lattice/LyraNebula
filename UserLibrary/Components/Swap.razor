@namespace UserLibrary.Components

@using AntDesign
@using CoinGecko.Clients
@using CoinGecko.Interfaces
@using Fluxor
@using Lyra.Core.API
@using Lyra.Core.Blocks
@using Lyra.Data.API
@using Lyra.Data.Crypto
@using Microsoft.Extensions.Configuration
@using Nebula.Store.WebWalletUseCase
@inject IConfiguration Configuration
@inject ILyraAPI lyraClient
@inject MessageService _message

<Styled>
    
.swt {
    margin: 10px;
    border-collapse: separate;
}

table.swt td {
    background-clip: padding-box;
    
    color: black;
    border: 5px solid white;
    border-radius: 5px;
}

</Styled>

<table cellspacing="0" cellpadding="0" class="swt">


    <tr>
        <td>From</td>
        <td>Balance: @balance1</td>
    </tr>
    <tr>
        <td><AntDesign.Input TValue="decimal" Placeholder="Enter an amount" @bind-Value="@amount1" OnChange="@updateBtn1" /></td>
        <td>
            <Select DataSource="@tickers"
                    @bind-Value="@selectedTicker1"
                    Style="width:220px"
                    OnSelectedItemChanged="OnSelectedItemChangedHandler1">
            </Select>
        </td>
    </tr>
    <tr>
        <td><Button Type="@ButtonType.Primary" Shape="@ButtonShape.Circle"
            Icon="@IconType.Outline.ArrowDown"
            OnClick="@DoSwapTicker"
             />
        </td>
        <td align="right"><Icon Type="setting" Theme="outline" /></td>
    </tr>
    <tr>
        <td>To</td>
        <td>Balance: @balance2</td>
    </tr>
    <tr>
        <td><AntDesign.Input TValue="decimal" Placeholder="Enter an amount" @bind-Value="@amount2" OnChange="@updateBtn2" /></td>
        <td>
            <Select DataSource="@tickers"
                    @bind-Value="@selectedTicker2"
                    Style="width:220px"
                    OnSelectedItemChanged="OnSelectedItemChangedHandler2">
            </Select>
        </td>
    </tr>
    @if (haspoolinfo)
    {
        <tr>
            <td colspan="2"><Divider /></td>
        </tr>
        <tr>
            <td>Token Pair</td>
            <td>@pairinfo</td>
        </tr>
        <tr>
            <td>Total Liquidate</td>
            <td>@pairliquid</td>
        </tr>

@*        <tr>
            <td>Your Share</td>
            <td>@pairshare</td>
        </tr>*@
    }
    else
    {
        <tr>
            <td colspan="2">Please select a token pair</td>
        </tr>

    }

    @if (dispswap)
    {
        <tr>
            <td colspan="2"><Divider /></td>
        </tr>
        <tr>
            <td>You will sell</td>
            <td>@calsell</td>
        </tr>
        <tr>
            <td>You will get</td>
            <td>@calget</td>
        </tr>
        <tr>
            <td>Price Impact</td>
            <td>@calimpact</td>
        </tr>
        <tr>
            <td>Liquidaty Provider Fee</td>
            <td>@calprofee</td>
        </tr>
        <tr>
            <td>Consensus Node Fee</td>
            <td>@calnodfee</td>
        </tr>
    }

    <tr>
        <td colspan="2"><Divider /></td>
    </tr>
    <tr>

        <td colspan="2">
            @if(walletState.Value.wallet == null)
            {
                <a href="/webwallet"> <Button Block Type="@ButtonType.Primary">Open Wallet</Button></a>
            }
            else
            {
                            <Button Block Disabled="@(!canswap)" Type="@ButtonType.Primary" 
            Icon="@IconType.Outline.Swap" Size="ButtonSize.Large" 
            OnClick="@(async ()=>{ await DoSwap(); })"
            Loading="@swapping"
            Shape="@ButtonShape.Round">Swap</Button>
            }


        </td>
    </tr>




</table>

@code {
    [Inject]
    private IState<WebWalletState> walletState { get; set; }

    [Inject]
    private IDispatcher Dispatcher { get; set; }

    [Parameter]
    public decimal amount1 { get; set; }

    decimal amount2;
    decimal balance1, balance2;
    List<string> tickers;
    string selectedTicker1;
    string selectedTicker2;

    RenderFragment pairinfo, pairliquid, pairshare;
    bool haspoolinfo = false;
    bool dispswap, canswap;
    bool swapping;

    RenderFragment calsell, calget, calimpact, calprofee, calnodfee;

    string token0, token1;
    TransactionBlock poollatest;
    decimal minrecv;
    decimal lyraprice;

    private void DoSwapTicker()
    {
        (selectedTicker1, selectedTicker2) = (selectedTicker2, selectedTicker1);
        (amount1, amount2) = (amount2, amount1);
        UpdateBalance();
        updateBtn1(amount1);
    }

    private async Task DoSwap()
    {
        swapping = true;
        var result = await walletState.Value.wallet.SwapTokenAsync(token0, token1, 
            selectedTicker1, amount1, minrecv);

        if(result.Successful())
        {
            await _message.Success($"Token Swap Success!");
            await walletState.Value.wallet.SyncAsync(null);

            var lc = LyraRestClient.Create(Configuration["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");
            var existspool = await lc.GetPoolAsync(selectedTicker1, selectedTicker2);
            if (existspool.Successful())
            {
                poollatest = existspool.GetBlock() as TransactionBlock;
                token0 = existspool.Token0;
                token1 = existspool.Token1;
                CreatePoolInfo(poollatest);
            }

            updateBtn1(amount1);
            UpdateBalance();
            swapping = false;
        }
        else
            await _message.Error($"Error Swap Token: {result.ResultCode}");

        swapping = false;
    }

    private void updateBtn1(decimal a)
    {
        if (poollatest != null && amount1 > 0 && token0 != null)
        {
            var swapcal = new SwapCalculator(token0, token1, poollatest,
                selectedTicker1, amount1, 0);
            amount2 = swapcal.MinimumReceived;

            dispswap = amount1 > 0;
            canswap = amount1 > 0 && amount1 <= balance1;
        }

        updateBtn(a);
    }

    private void updateBtn2(decimal a)
    {
        if (poollatest != null && amount1 > 0 && token0 != null)
        {
            var swapcal = new SwapCalculator(token0, token1, poollatest,
                selectedTicker2, amount1, 0);
            amount1 = swapcal.MinimumReceived;

            dispswap = amount2 > 0;
            canswap = amount2 > 0 && amount2 < balance2;
        }
        updateBtn(a);
    }
    private void updateBtn(decimal a)
    {
        if (dispswap && amount1 > 0 && token0 != null)
        {
            var swapcal = new SwapCalculator(token0, token1, poollatest,
                selectedTicker1, amount1, 0);
            var sell = $"{amount1} {selectedTicker1}";
            calsell =
    @<div>@sell</div>
    ;

            minrecv = swapcal.MinimumReceived;
            var minget = $"{swapcal.MinimumReceived} {selectedTicker2}";
            calget =
    @<div>@minget</div>
    ;

            var imp = $"{swapcal.PriceImpact * 100} %";
            calimpact =
    @<div>@imp</div>
    ;

            var feen = $"{swapcal.PayToAuthorizer} LYR";
            var feep = $"{swapcal.PayToProvider} {selectedTicker1}";
            calnodfee =
    @<div>@feen</div>
    ;
            calprofee =
    @<div>@feep</div>
    ;
        }
    }

    private void OnSelectedItemChangedHandler1(string value)
    {
        UpdateBalance();
        ChangePool();
    }
    private void OnSelectedItemChangedHandler2(string value)
    {
        UpdateBalance();
        ChangePool();
    }

    private void ChangePool()
    {
        _ = Task.Run(async () =>
        {
            var lc = LyraRestClient.Create(Configuration["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");

            var existspool = await lc.GetPoolAsync(selectedTicker1, selectedTicker2);
            if (existspool.Successful())
            {
                poollatest = existspool.GetBlock() as TransactionBlock;
                token0 = existspool.Token0;
                token1 = existspool.Token1;
                CreatePoolInfo(poollatest);
            }
            else
            {
                CreatePoolInfo(null);
            }

            updateBtn1(amount1);
            UpdateBalance();
            await InvokeAsync(() => StateHasChanged());
        });
    }

    private void UpdateBalance()
    {
        if (walletState.Value.wallet != null)
        {
            var blk = walletState.Value.wallet.GetLatestBlock();

            if (selectedTicker1 != null)
                if (blk != null && blk.Balances.ContainsKey(selectedTicker1))
                    balance1 = blk.Balances[selectedTicker1].ToBalanceDecimal();
                else
                    balance1 = 0;

            if (selectedTicker2 != null)
                if (blk != null && blk.Balances.ContainsKey(selectedTicker2))
                    balance2 = blk.Balances[selectedTicker2].ToBalanceDecimal();
                else
                    balance2 = 0;
        }

        //InvokeAsync(() => StateHasChanged());
    }

    private async Task OpenSwapUI()
    {
        var lc = LyraRestClient.Create(Configuration["network"], Environment.OSVersion.ToString(), "Nebula", "1.4");

        // for api sign only
        var pk = "n4uh7o2kAerPZQSNBRirzA3pSUBEuEhs6r7oRwpV6Dgbs3FvY";
        var pub = "LBRzScs8NwMcr7U8i9a8sSWETseWf3TLge4CVJy6as24hSB4hwtZ5jKTbHJdoVZBJiNC2LpjN9MQB719Py9YxXo2xpLxnS";

        var lsbret = await lc.GetLastServiceBlockAsync();

        var sign = Signatures.GetSignature(pk, (lsbret.GetBlock() as ServiceBlock).Hash, pub);
        var tokens = await lc.GetTokenNamesAsync(pub, sign, "(null)");

        tickers = tokens.Entities
            .Where(a => !a.StartsWith("unittest/"))
            .ToList();
        tickers.Insert(0, "LYR");

        ICoinGeckoClient _client = CoinGeckoClient.Instance;
        const string vsCurrencies = "usd";
        var prices = await _client.SimpleClient.GetSimplePrice(new[] { "lyra" }, new[] { vsCurrencies });
        lyraprice = (decimal)prices["lyra"]["usd"];
    }

    protected override async Task OnInitializedAsync()
    {
        //this.ObserveParameter<decimal>(nameof(this.amount1))
        //    .TakeUntil(Disposed) //you could even move this to the base class
        //    .Subscribe();

        await base.OnInitializedAsync();

        if (walletState.Value.wallet != null)
            await walletState.Value.wallet.SyncAsync(null);
        await OpenSwapUI();
    }


    private void CreatePoolInfo(TransactionBlock platest)
    {
        if (platest != null)
        {
            var info = $"{token0} vs {token1}";
            pairinfo =
    @<p>@info</p>
    ;

            if (platest.Balances.ContainsKey(token0))
            {
                var line1 = $"{platest.Balances[token0].ToBalanceDecimal()} {token0}";
                var line2 = $"{platest.Balances[token1].ToBalanceDecimal()} {token1}";
                pairliquid =
    @<p>
        @line1<br />
        @line2
    </p>
    ;
            }
            else
            {
                pairliquid =
    @<p>No Liquidate in Pool</p>
    ;
            }
        }
        else
        {
            pairinfo =
    @<p>No pool for selected token pair.</p>
    ;

            pairliquid =
    @<p>No Liquidate in Pool</p>
    ;
        }


        var pool = platest as IPool;
        if (pool != null && walletState.Value.wallet != null)
        {
            if (pool.Shares.ContainsKey(walletState.Value.wallet.AccountId))
            {
                var shareinfo = $"{pool.Shares[walletState.Value.wallet.AccountId].ToRitoDecimal() * 100} %";
                pairshare =
    @<p>@shareinfo</p>
    ;
            }
            else
            {
                pairshare =
    @<p>You don't have Share in Pool</p>
    ;
            }
        }
        else
        {
            pairshare =
    @<p>No Share in Pool</p>
    ;
        }

    ;

        haspoolinfo = true;
    }
}
