@namespace UserLibrary.Pages
@page "/webwallet"
@page "/wallet"

@inherits Fluxor.Blazor.Web.Components.FluxorComponent

@using AntDesign
@using Fluxor
@using Lyra.Core.API
@using Lyra.Data.API
@using Lyra.Data.Crypto
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using Nebula.Store.WebWalletUseCase
@using Nebula.Data
@using Microsoft.Extensions.Configuration
@using Blazored.LocalStorage
@using Microsoft.Extensions.Logging
@using Microsoft.Extensions.Options
@inject IConfiguration Configuration
@inject NavigationManager Navigation
@inject Blazored.LocalStorage.ILocalStorageService localStore
@inject ILogger<WebWallet> logger
@inject ILyraAPI lyraClient
@using UserLibrary.Components;

@if (walletState.Value.IsLoading)
{
    <div class="spinner"></div>
}

@if (!string.IsNullOrEmpty(walletState.Value.error))
{
    <p>
        <Alert Type="@AlertType.Error"
           Message="Wallet Operation Error"
           Description="@walletState.Value.error"
           ShowIcon="true" Closable OnClose="ClearError" />
    </p>
}

@if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Main)
{
    <div>
        <Space Size=@(("8", "16")) Wrap>
            <SpaceItem>
                <button class="btn btn-primary" @onclick="Send">
                    Send
                </button>
            </SpaceItem>

            <SpaceItem>
                <button class="btn btn-primary" @onclick="Refresh">
                    Receive
                </button>
            </SpaceItem>

            <SpaceItem>
                <button class="btn btn-primary" @onclick="Staking">
                    Staking
                </button>
            </SpaceItem>

            <SpaceItem>
                <button class="btn btn-primary" @onclick="StartDex">
                    DEX
                </button>
            </SpaceItem>

            <SpaceItem>&nbsp;</SpaceItem>

            <SpaceItem>
                <button class="btn btn-primary" @onclick="Settings">
                    Settings
                </button>
            </SpaceItem>

            <SpaceItem>
                <button class="btn btn-primary" @onclick="CloseWallet">
                    Close
                </button>
            </SpaceItem>

        </Space>
        &nbsp;&nbsp;&nbsp;
        @if (Configuration["network"] != "mainnet" && walletState.Value.wallet.BaseBalance == 0m && !walletState.Value.freeTokenSent) //&& walletState.Value.freeTokenTimes < 3
        {
            <span>
                <button style="float: right;" class="btn btn-success" @onclick="FreeToken">
                    Get Free Token
                </button>
            </span>
        }
    </div>
    <hr />
    <div>
        <Space Size=@(("8", "16")) Wrap>
            @if (walletState.Value.wallet.GetLatestBlock() != null)
            {
                @foreach (var kvp in walletState.Value.wallet.GetLatestBlock().Balances)
                {
                    <SpaceItem>
                        <Card Title="@kvp.Key" Style="height:180px; width:280px;">
                            <Extra>
                                <Button Type="@ButtonType.Text" OnClick="@(async ()=>{ await SendX(kvp.Key); })">
                                    Send
                                </Button>
                            </Extra>
                            <Body>
                                <p style="font-size: xx-large; text-align: right;4"><b>@($"{kvp.Value.ToBalanceDecimal():N4}")</b></p>
                            </Body>
                        </Card>
                    </SpaceItem>
                }

                    <SpaceItem Style="display: none">
                        <Card Title="Your New Token" Style="height:180px; width:280px;">
                            <Extra>
                                <Button Type="@ButtonType.Text" >
                                    ...
                                </Button>
                            </Extra>
                            <Body>
                                <p style="font-size: xx-large; text-align:center;"><b><Button Type="@ButtonType.Primary" 
                                    Shape="@ButtonShape.Circle" Icon="@IconType.Outline.Plus" 
                                    Size="@ButtonSize.Large"/>
                                </b></p>
                            </Body>
                        </Card>
                    </SpaceItem>
            }


        </Space>


    </div>

}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.DEX)
{
    <div>
        <button class="btn btn-primary" @onclick="CancelSave">Return</button>
    </div>
    <hr />
    <h3>Lyra DEX</h3>
    <hr />
    <div>
        <UserLibrary.Components.DexWallets></UserLibrary.Components.DexWallets>
    </div>
    <hr />
    <div>
        <button class="btn btn-primary" @onclick="CancelSave">Return</button>
    </div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Staking)
{
    <div>
        <button class="btn btn-primary" @onclick="CancelSave">Return</button>
    </div>
    <hr />
    <h3>Staking</h3>
    <hr />
    <Staking />
        <hr />
    <div>
        <button class="btn btn-primary" @onclick="CancelSave">Return</button>
    </div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Settings)
{
    <h3>Settings</h3>
    <hr />
    <div>
        <p><span title="Click to toggle to display" @onclick="ToggleKey">Your wallet's private key is (click to unhide/hide): </span><span>@altDisplay</span></p>
        <p>Your wallet's address is: <a href="/showblock/@walletState.Value.wallet.AccountId">@walletState.Value.wallet.AccountId</a></p>
        <p>Your wallet's balance is: @walletState.Value.balanceString</p>
        <p>Your are now voting for: @walletState.Value.wallet.VoteFor</p>

        <p>
            Vote For Address:
            <Input TValue="string" Placeholder="Address" @bind-Value="@voteAddr" /> 
        </p>
        <div>
            <p style="color: red">Please save private key properly if you want to open this wallet again.</p>
        </div>
        <hr />
                        <button class="btn btn-primary" @onclick="Transactions">
                    Transactions
                </button>
        <button class="btn btn-primary" @onclick="SaveSettings">Save</button>
        <button class="btn btn-primary" @onclick="CancelSave">Cancel</button>
    </div>
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Send)
{
    <h3>Sending token</h3>
    <hr />
    <div>
        <p>
            Destination Wallet Address:<br />
            <Input TValue="string" Placeholder="Address" @bind-Value="@dstAddr" /> 
        </p>
        <p>
            Token Name:<br />
            <Input TValue="string" Placeholder="Name" @bind-Value="@tokenName" /> 
        </p>
        <p>
            Amount:<br />
            <Input TValue="decimal" Placeholder="Amount" @bind-Value="@amount" /> 
        </p>
        <hr />
        <button class="btn btn-primary" @onclick="SendToken">Send Token</button>
        <button class="btn btn-primary" @onclick="CancelSend">Cancel</button>
    </div>

}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.Transactions)
{
    <h3>Transactions</h3>
    <hr />
    <div>
        <button class="btn btn-primary" @onclick="Return">Return</button>
    </div>
    @if (walletState.Value.txs != null)
    {
        <pre>
            @foreach (var tx in walletState.Value.txs)
            {
                @tx <br />

            }
                        </pre>
        <div>
            <button class="btn btn-primary" @onclick="Return">Return</button>
        </div>
    }
}
else if (walletState.Value.IsOpening && walletState.Value.stage == UIStage.FreeToken)
{
    <h3>Verify and get free LYR</h3>
    <hr />
    <div>
        <p>Current balance of faucet account: <em>@walletState.Value.faucetBalance</em> LYR</p>
    </div>

    @*    <div class="section">
        <ReCAPTCHA @ref="reCAPTCHAComponent" SiteKey="6Lftd8gZAAAAAK5G9aHUFY7wtV1yocfAf2Vj-EmI" OnSuccess="OnSuccess" OnExpired="OnExpired" />
        </div>*@

    <div class="section">
        <button class="btn btn-success" @onclick="OnClickPost" disabled="@walletState.Value.DisablePostButton">
            Send me Token!
        </button>
        &nbsp;&nbsp;
        <button class="btn btn-primary" @onclick="Return">Return</button>
    </div>
}
else
{
    <div>
        <button class="btn btn-primary" @onclick="CreateWallet">
            Create New Wallet
        </button>
    </div>
    <hr />
    <div>
        <p>Private Key:</p>
        <p>
            <Input TValue="string" Placeholder="Private Key" @bind-Value="@prvKey" />    
        </p>
        <p>
            <button class="btn btn-primary" @onclick="RestoreWallet">
                Restore Wallet
            </button>
        </p>
    </div>
}

@code{
    		[Inject]
		private IState<WebWalletState> walletState { get; set; }

		[Inject]
		private IDispatcher Dispatcher { get; set; }

		[Inject]
		private IJSRuntime JS { get; set; }

        		public string prvKey { get; set; }
		public bool selfVote { get; set; }

		// for send
		public string dstAddr { get; set; }
		public string tokenName { get; set; }
		public decimal amount { get; set; }

		// for settings
		public string voteAddr { get; set; }

		public string altDisplay { get; set; }

		public WebWallet()
        {
			tokenName = "LYR";
			altDisplay = "************";			
		}

        private void ToggleKey(MouseEventArgs e)
		{
			if (altDisplay == "************")
				altDisplay = walletState?.Value?.wallet?.PrivateKey;
			else
				altDisplay = "************";
		}

		private void CloseWallet(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletCloseAction());
		}

		private void CreateWallet(MouseEventArgs e)
        {
			altDisplay = "************";

			Dispatcher.Dispatch(new WebWalletCreateAction{name = "tmp", password = "tmp"});
		}

		private async void RestoreWallet(MouseEventArgs e)
		{
			altDisplay = "************";

			if (string.IsNullOrWhiteSpace(prvKey))
            {
				await JS.InvokeAsync<object>("alert", "Private Key can't be empty.");
				return;
			}
            else
            {
				try
                {
					Base58Encoding.DecodePrivateKey(prvKey);
					Dispatcher.Dispatch(new WebWalletRestoreAction { privateKey = prvKey, selfVote = this.selfVote });
				}
				catch (Exception)
                {
					await JS.InvokeAsync<object>("alert", "Private Key specified is not valid.");
					return;
				}
            }
		}

		private void Refresh(MouseEventArgs e)
        {
			Dispatcher.Dispatch(new WebWalletRefreshBalanceAction { wallet = walletState.Value.wallet });
        }

		private void Staking(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletStakingAction { wallet = walletState.Value.wallet });
		}

		private void ClearError()
		{
			Dispatcher.Dispatch(new WalletErrorResetAction());
		}







		private void OnSuccess()
		{
			Dispatcher.Dispatch(new WebWalletReCAPTCHAValidAction { ValidReCAPTCHA = true });
		}

		private void OnExpired()
		{
			Dispatcher.Dispatch(new WebWalletReCAPTCHAValidAction { ValidReCAPTCHA = false });
		}

		private async Task OnClickPost()
		{
			Dispatcher.Dispatch(new WebWalletSendMeFreeTokenAction
			{
				wallet = walletState.Value.wallet,
				faucetPvk = Configuration["faucetPvk"]
			});
			return;

			/*        if (walletState.Value.ValidReCAPTCHA)
					{
						var response = await reCAPTCHAComponent.GetResponseAsync();
						try
						{
							Dispatcher.Dispatch(new WebWalletReCAPTCHAServerAction { ServerVerificatiing = true });

							var result = await SampleAPI.Post(response);
							if (result.Success)
							{
								Dispatcher.Dispatch(new WebWalletSendMeFreeTokenAction
									{
										wallet = walletState.Value.wallet,
										faucetPvk = Configuration["faucetPvk"]
									});
								//Navigation.NavigateTo("/valid");
							}
							else
							{
								await JS.InvokeAsync<object>("alert", string.Join(", ", result.ErrorCodes));

								Dispatcher.Dispatch(new WebWalletReCAPTCHAServerAction { ServerVerificatiing = false });
							}
						}
						catch (HttpRequestException e)
						{
							await JS.InvokeAsync<object>("alert", e.Message);

							Dispatcher.Dispatch(new WebWalletReCAPTCHAServerAction { ServerVerificatiing = false });
						}
					}*/
		}

		//protected override async Task OnAfterRenderAsync(bool firstRender)
		//{
		//	var key = Configuration["network"] + "freelyr";
		//	if (walletState.Value.freeTokenTimes.HasValue)
		//	{
		//		// if it need save
		//		var oldValue = await localStore.GetItemAsync<string>(key);
		//		int oldCount;
		//		if (oldValue == null || (int.TryParse(oldValue, out oldCount) && oldCount < walletState.Value.freeTokenTimes))
		//		{
		//			await localStore.SetItemAsync(key, walletState.Value.freeTokenTimes.ToString());
		//		}
		//	}
		//	else
		//	{
		//		var oldValue = await localStore.GetItemAsync<string>(key);
		//		int oldCount;
		//		if (oldValue != null && int.TryParse(oldValue, out oldCount))
		//		{
		//			walletState.Value.freeTokenTimes = oldCount;
		//		}
		//		else
		//		{
		//			walletState.Value.freeTokenTimes = 0;
		//		}
		//	}
		//}

		private async Task Send(MouseEventArgs e)
		{
			if(walletState.Value.wallet.BaseBalance > 1)
				Dispatcher.Dispatch(new WebWalletSendAction {   });
			else
				await JS.InvokeAsync<object>("alert", "Nothing to send.");
		}

		private async Task SendX(string name)
		{
			tokenName = name;
			if (walletState.Value.wallet.BaseBalance > 1)
				Dispatcher.Dispatch(new WebWalletSendAction { });
			else
				await JS.InvokeAsync<object>("alert", "Nothing to send.");
		}

		private void SendToken(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletSendTokenAction { DstAddr = dstAddr, TokenName = tokenName, Amount = amount, wallet = walletState.Value.wallet });
		}

		private void CancelSend(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletCancelSendAction ());
		}

		private void Settings(MouseEventArgs e)
		{
			voteAddr = walletState.Value.wallet.VoteFor;
			Dispatcher.Dispatch(new WebWalletSettingsAction { });
		}

		private void SaveSettings(MouseEventArgs e)
        {
			Dispatcher.Dispatch(new WebWalletSaveSettingsAction { VoteFor = voteAddr });
        }

		private void CancelSave(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletCancelSaveSettingsAction { });
		}

		private void Transactions(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletTransactionsAction { wallet = walletState.Value.wallet });
		}

		private void Return(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletCancelSaveSettingsAction { });
		}

		private void FreeToken(MouseEventArgs e)
		{
			Dispatcher.Dispatch(new WebWalletFreeTokenAction { faucetPvk = Configuration["faucetPvk"] });
		}

		private void StartDex(MouseEventArgs e)
		{		
			Dispatcher.Dispatch(new WebWalletStartDexAction());
		}
}